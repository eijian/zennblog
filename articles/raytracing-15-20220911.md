---
title: "レイトレーシング(15): 物理ベースレンダリング（もどき）"
emoji: "💡"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Haskell", "RayTracing", "PhotonMapping"]
published: false
---

今回は自身の忘備録（何をどう解釈してどう実装したかすぐ忘れるので）も兼ねて、物理ベースレンダリング(Physically Based Rendering: PBR)への取り組みについて書こうと思う。これまでの記事とオーバーラップする部分もあるのはご愛嬌。

物理ベースレンダリング（以後PBRと表記）は色々なサイトや書籍で説明されている。なので詳しいことや正確なことはそちらを参考にしていただきたい。このブログは自分なりにPBRを解釈し、それをどうプログラミングに落とし込んだかを書くので間違いも多く含まれている可能性が高い。その辺はご容赦願いたい。私が参考にした情報のいくつかを列挙する。

(Webサイト)

* [物理ベースレンダリング入門 その① - 物理ベースレンダリングとは？](https://light11.hatenadiary.com/entry/2020/03/02/204305)
* [物理ベースレンダリング -基礎編-](https://tech.cygames.co.jp/archives/2129/)
* [物理ベースレンダリングを柔らかく説明してみる（１）](https://qiita.com/emadurandal/items/3a8db7bc61438245654d)

(書籍)

* [1] フォトンマッピング-写実に迫るコンピュータグラフィックス(オーム社)
* [2] CGWORLD vol.265 (SEP.2020)

## 1. 理論編

実装の前にPBRの理論面について確認しておこう。

### -1. 物体に衝突した時の光の挙動

まず最初に、PBRで最も重要なことは「エネルギー保存則」である。ある物体表面に入射した光のエネルギーは、この後説明するいずれかの状態になるが、その合計は入射したエネルギーと等価でありそれ以上にもそれ以下にもならない。これに反したレンダリング処理をすると現実感のない画像になるのである（計算で疑似的に作られたハイライトなど）。

下は入射した光がその後どのような状態になるかを表した図である。

（図）

まず物体へ入射した光は、鏡面反射して物体の外へ跳ね返されるか、物体の中に吸収されるのどちらかになる。この鏡面反射する割合が鏡面反射率であり、それを$s$とすると当然吸収される率は $1-s \quad (0 \leq s \leq 1)$になる。物体に吸収された光は、その後物体内を通り抜けていくが、ここでいくつかに分かれる。あるものは物体内をランダムな方向へ進んだのち再び外に出てくる(微小面散乱：subsurface scattering)。あるものは物体内を直進していく（透過）。そしてそれ以外は熱に換わる（発熱）。それら入射後の状態は違えど、そのエネルギーの合計は入射したエネルギーと全く同じになるのである。そこを考慮してレンダラーを設計しなければならない。

1. 鏡面反射
2. 物体に吸収
    1. 微小面散乱
    2. 透過
    3. 発熱

以後の説明では、まず物体表面が完全に滑らかな場合（平滑面）における入射光の各状態について書き、最後に滑らかでない場合（光沢面や拡散面）について補足する。

### -2. 鏡面反射

光が平滑な物体に入射すると一部は入射方向に対し面法線に対し真逆（同じ角度）の方向へ反射する。これを鏡面反射という。

（図）

入射エネルギーの何割が反射するかを反射率と言い、これは光が入射する側の物体と衝突する側の物体の屈折率(Index of Refraction: IOR)によって決まる。光学的な正確な式は書籍1を読んでいただくとして、実装に際しては下記の式で計算できる（入射角$\theta$が0°、物体真上から垂直に物体に入射した場合）。

$$
  s(\lambda) = \left(\frac{\eta_1(\lambda) - \eta_2(\lambda)}{\eta_1(\lambda) + \eta_2(\lambda)}\right) ^2   \qquad (1.1)
$$

ここで$\eta_1$は入射する側の物体の屈折率、$\eta_2$は入射される側の物体の屈折率である。なお屈折率とは新空中の光速を物質中の光速で割った値であり、真空の屈折率は1である。ポイントは3つある。まず、屈折率は透明じゃない物体（木や石とか）にもあること、だから金属にも屈折率はあってそれは複素数であること、屈折率は光の波長($\lambda$)によって異なることだ。よってその物質の屈折率がわかれば反射率も「計算できる」ということである。以前の実装では「透明でない物質の屈折率パラメータは0にし、反射率もパラメータとして別途与えていた」が、PBRの考え方では「屈折率を与えて反射率は計算で求める」ことができるわけだ。ただ実装においては、金属の場合「パラメータとして与える」方が都合が良さそうだ（後述）。

あと反射率は入射角により大きく変化する。金属は入射角0°でも比較的高い数値だが、それ以外（誘電体とよぶ）はかなり小さい数値である。

※ このサイトが詳しい: [フレネル反射率について](https://hanecci.hatenadiary.org/entry/20130525/p3)

|物質|入射角0°の反射率($F_0$)|
|:--|:-:|
|水| 0.02|
|ガラス|0.08|
|ダイヤモンド|0.12|
|金(700nm)|0.96|
|銀(700nm)|0.97|

一方このサイトの「フレネル反射率のグラフ」を見ると、入射角が90°に近づくにつれどんな物質も反射率が1.0になっていくのがわかるが、その曲線はまちまちであり特に金属では80°付近で一旦下がる場合もある。よって様々な入射角に対し反射率を正確に求めるのは負荷が高いが、そこは「Schlickの近似式」というものがあって、入射角$\theta$における反射率$F_r(\theta)$は入射角0°の反射率($F_0$)があれば程よい近似値をすぐ計算できる。実装ではこれを使う。

$$
F_r(\theta) \approx F_0 + (1 - F_0)(1 - \cos \theta)^5   \qquad (1.2)
$$

なお、金属の反射率を求める方法は複素数の計算にはなるが上記(1.1)式をそのまま当てはめればよい。ただし結果が複素数になるので、そのノルムを取る必要がある。たとえば金の波長700nmでの屈折率はおよそ$0.161 + 4.088i$であるから、真空から垂直に入射した時の反射率は、

$$
\begin{aligned}
f   &= \left(\frac{1.000 - (0.161+4.088i)}{1.000 + (0.161+4.088i)}\right)^2 \\
    &= \left(\frac{0.839 - 4.088i}{1.161+4.088i}\right)^2 \\
    &= \left(-0.871 - 0.453i\right)^2 \\
    &= 0.553 + 0.789i \\
F_0 &\approx |f| = |0.553 + 0.789i| = 0.963 \qquad (1.3)
\end{aligned}
$$

となる。金属など各物質の屈折率は下記サイトも参考にさせていただいた。

[FILMETRICS: Gold,金屈折率](https://www.filmetricsinc.jp/refractive-index-database/Au/Gold-金)


### -3. 散乱

金属以外の物質（誘電体）では、鏡面反射せず物体内に光が入ることがあり、入った光の一部は内部で散乱する（分子に当たってランダムな方向に弾かれる）。その光が熱にかわらず最終的にもう一度物体の外に出る場合、それが物体の「色」と認識される。

（図）

内部で散乱して外に出る場合、大半は入射した場所からそれほど離れていない場所から出ると考えられるが、それを微小面散乱(subsurface scattering)という。これを真面目に計算するのがBSSRDF（双方向散乱面反射率分布関数）、近似するのがBRDF（双方向反射率分布関数）という理解。BSSRDFは負荷が高いため、レンダラーの実装では入射した場所から出ると「近似」して計算していることが多いと思われる。なお書籍1にはフォトンマッピング法でこのBSSRDFを実現する手法が書いてある。

物体内を散乱する光は外へ出ずに熱へと変わる場合があるがその割合は光の波長によって異なり、それが物体色として現れてくる。赤い物質は赤以外の波長の光が内部で熱に換わりやすく、赤い光は散乱後に外へ出てきやすいということだ。なので黒い物体はほとんどの光が内部で熱に換わり、だから熱くなりやすいのだ。

PBRの話でよく出てくる「アルベド」は先の鏡面反射も含めた反射比率（入射量に対する反射量の比率）のことと思うが、後述する私の実装では物体内に入った後で散乱して外に出る光の比率を「アルベド（拡散）」としてパラメータにした。

### -4. 透過

物体内に入った光は上記の通り一部は散乱（か熱に変化）するが、それ以外は物体内を透過する。ガラスなどの透明な物質は光がほとんど散乱せず入射光は直進し、物質の境界でさらに透過もしくは逆に反射する。

（図）

がラスの向こうから来た光が透過して外に出てきたものを我々は目で観測するので「透明」だと感じるのだ。透過する光も波長によって透過しやすい・しにくいがあり、ステンドグラスなどの色ガラスは波長によっては途中で熱に変わってしまい外に出てこない。入射光の強度を$I_0(\lambda)$、透過した後の出力光の強度を$I(\lambda)$、単位長さあたりに光が透過する割合を$T(\lambda)[/m]$、透過した距離を$t[m]$とすると、

$$
I(\lambda) = I_0(\lambda) \cdot T(\lambda)^t  \qquad (1.4)
$$

と表現できる。実装に際しては、この$T(\lambda)$をパラメータで与えることで色ガラスなどを表現できるようにする。

なお、光は物体内で散乱（途中で発に変化するもの含む）・透過（途中で発に変化するもの含む）のどちらかになるので、その確率をそれぞれ$p_d, p_t$とすると、

$$
p_d + p_t = 1 \qquad (p_d \geq 0, \quad p_t \geq 0)   \qquad (1.5)
$$

である。

### -5. 発熱

これまで書いた通り、物質に入射した光は、鏡面反射、散乱、透過もしくは熱に変化する。金属とそれ以外で異なるので注意が必要。

* 金属: 鏡面反射かそうでなければ全て熱に変化(散乱・透過はしない)
* 誘電体: どの状態にもなりうる。

いずれにせよ、入射した光のエネルギーの一部は熱に換わるわけだが、レンダラーにとって熱は表現対象ではないので無視する。

### -6. 光沢面(glossy)や拡散反射について

※ この部分は私の解釈なので間違いが多く含まれている可能性が特に高く、その場合は有識者の方にご指導いただきたい。

3D-CGの説明では物体表面での光の反射について、鏡面反射（磨かれた金属）か拡散反射（紙など）、もしくはその中間の反射（光沢面）のいずれかになる、といった風に書かれていることがある。間違いではないのだが、PBRを理解する上では中途半端というか、上記で書いてきたような光の物理現象と、物体表面の粗さによって生じるマクロな観測結果をごちゃ混ぜにしている気がしてならない。

物体表面がどんなに「粗い」状態であっても、非常にミクロな部分では完全に平滑な面であると考えてよく、光は入射したあと必ず上記のような枝分かれをしていると考えられる。

（図）

ただ粗い表面ではミクロな面の法線がマクロな物体の法線とずれているため、鏡面反射をしてもマクロでは色々な方向に光が反射するということである。だから拡散面でも光沢な面でも反射する光は須く「鏡面反射」の結果である。前回記事でも書いたが、少し粗い表面にぼんやり「ハイライト」が生じるのは、この鏡面反射の結果であって、拡散反射なる別の事象ではない。

一方、ノートの紙が白っぽかったり、木が茶色系の色に見えるのは光が物体に衝突した点で「拡散反射」したのではなく、内部を少し散乱して表面に出てきた光が、散乱の結果としてランダムな方向に飛び出していくからである。それをマクロに見ると全体では方々へ拡散して反射しているように見える、というのが私の理解だ。散乱によって生じる「物体の色」と「鏡面反射率」は別ものであるから、光の物理現象により生じる効果と、物体表面の粗さ度合いによって引き起こされる効果を分けて考え、実装する必要がある。

なお粗い物体面を正しく扱うには、本来ならマイクロファセット理論を理解する必要があろう。大雑把には、粗い表面は様々な法線方向を向いた微小な平面の集まりであり、それを考慮して反射・透過などを考えるのだが、単純に法線が色々な方向であるというだけでなく、反射したものが近くの微小平面に邪魔されて目に見えない（マスキング）状況や、近くの微小平面が覆って光が届かない（シャドウイング）状況も考慮する必要があり、厳密な計算には高度な数式の理解が必要のようだ。私もまだ勉強中なので、現時点の実装はマイクロファセット理論を反映していない。

* [ushiostarfish’s diary: Microfacet入門（１）](https://ushiostarfish.hatenablog.com/entry/2018/03/18/213904)
* [物理ベースレンダリングを柔らかく説明してみる（４）](https://qiita.com/emadurandal/items/76348ad118c36317ec5c)

## 2. 実装編

### -1. PBR用パラメータ


### -2. フォトン追跡



### -3. レンダリング

## (参考)

現在の実装は[こちら](https://github.com/eijian/raytracer/tree/version-2.7.5.0)


---
